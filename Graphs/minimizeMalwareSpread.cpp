// Minimize malware spread: https://leetcode.com/problems/minimize-malware-spread/

/*
    Intuition:  1.  Perform dfs on each infected node and count 2 things: number of total nodes and number of infected nodes in the component.
                2.  If number of infected nodes is 1 in a component and it has the largest number of total nodes, mark it as the answer.
                3.  Repeat the above steps till all the nodes are visited.
                4.  If no component had 1 infected node, return the smallest value in the initial as the answer.
*/
class Solution 
{
public:
    
    int n;
    int ans = -1;
    unordered_set<int> infected;
    vector<bool> visited;
    int big = -1;
    int count, infectedCount;
    
    void dfs(int u, vector<vector<int>> &graph)
    {
        visited[u] = true;
        if(infected.count(u) == 1)
            infectedCount++;
        
        count++;
        for(int v = 0; v < n; v++)
            if(graph[u][v] == 1 && !visited[v])
                dfs(v, graph);
    }
    
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) 
    {
        n = graph.size();
        
        for(auto e: initial)
            infected.insert(e);
        
        visited = vector<bool>(n, false);
        
        sort(initial.begin(), initial.end());
        
        for(auto u: initial)
        {
            if(!visited[u])
            {
                count = 0;
                infectedCount = 0;
                dfs(u, graph);
                if(infectedCount == 1 && big < count)
                {
                    big = count;
                    ans = u;
                }
            }
        }
        
        return ans == -1 ? initial[0] : ans;
    }
    
};